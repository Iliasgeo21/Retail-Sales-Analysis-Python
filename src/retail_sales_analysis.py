# -*- coding: utf-8 -*-
"""retail_sales_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rOOtDTXEnab_Mekur-THuhKVqQEQJD9k

# üõí Online Retail Sales Analysis & RFM Customer Segmentation

This project performs end-to-end analysis on the **Online Retail dataset**, including:

- ‚úÖ Exploratory Data Analysis (EDA)
- ‚úÖ Data cleaning & preprocessing
- ‚úÖ Revenue and sales KPIs
- ‚úÖ Product, country, and customer insights
- ‚úÖ RFM Analysis (Recency, Frequency, Monetary)
- ‚úÖ RFM Scoring & Customer Segmentation
- ‚úÖ K-Means clustering on RFM features
- ‚úÖ Business recommendations

The dataset contains real e-commerce transactions from a UK-based retailer (2010‚Äì2011).

## 1Ô∏è‚É£ Import Necessary Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""## 2Ô∏è‚É£ Load Dataset

We upload the **Online Retail.xlsx** file and load it into a pandas DataFrame.

"""

from google.colab import files
uploaded = files.upload()

df = pd.read_excel("Online Retail.xlsx", engine="openpyxl")

"""## 3Ô∏è‚É£ Dataset Overview

A first look at the dataset including:
- Sample rows
- Data types
- Summary statistics

"""

df.head(), df.info(), df.describe()

"""## 4Ô∏è‚É£ Data Cleaning

We clean the dataset using the following steps:

- ‚ùå Remove cancelled transactions (InvoiceNo starting with "C")
- ‚ùå Remove negative quantities  
- ‚ùå Remove missing CustomerID values  
- ‚úÖ Convert InvoiceDate to datetime  
- ‚úÖ Create Revenue = Quantity √ó UnitPrice  
- ‚ùå Filter extreme UnitPrice values  
- ‚úÖ Remove duplicates  
- ‚úÖ Reset index  

After cleaning, the dataset is ready for analysis.

"""

# Remove cancelled orders (InvoiceNo starting with "C")
df = df[~df['InvoiceNo'].astype(str).str.startswith('C')]

df = df[df['Quantity'] > 0]

df = df.dropna(subset=['CustomerID'])

df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])

df['Revenue'] = df['Quantity'] * df['UnitPrice']

df = df[df['UnitPrice'] <= 5000]

df = df.drop_duplicates()

df = df.reset_index(drop=True)


df.info()
df.describe()
df.head()

"""## 5Ô∏è‚É£ Key Dataset Metrics

We calculate key business metrics such as:

- Number of unique customers  
- Number of products  
- Number of invoices  
- Number of countries  

"""

print("Unique customers:", df['CustomerID'].nunique())
print("Unique products:", df['StockCode'].nunique())
print("Unique invoices:", df['InvoiceNo'].nunique())
print("Countries:", df['Country'].nunique())

"""## 6Ô∏è‚É£ Revenue by Country (excluding UK)

We analyze which countries generate the highest revenue outside the United Kingdom.

"""

country_sales = (
    df[df['Country'] != "United Kingdom"]
    .groupby("Country")['Revenue']
    .sum()
    .sort_values(ascending=False)
    .head(10)
)

plt.figure(figsize=(10,5))
sns.barplot(x=country_sales.values, y=country_sales.index)
plt.title("Top 10 Countries by Revenue (excluding UK)")
plt.xlabel("Revenue")
plt.ylabel("Country")
plt.show()

"""## 7Ô∏è‚É£ Monthly Revenue Trend

We group transactions by month and plot the monthly revenue time series.

"""

df['InvoiceMonth'] = df['InvoiceDate'].dt.to_period('M').astype(str)

monthly_revenue = df.groupby('InvoiceMonth')['Revenue'].sum()

plt.figure(figsize=(12,5))
monthly_revenue.plot(marker="o")
plt.title("Monthly Revenue Trend")
plt.ylabel("Revenue")
plt.xlabel("Month")
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

"""## 8Ô∏è‚É£ Top 10 Products by Revenue

Identifying the products that contribute the most to total revenue.

"""

top_products = (
    df.groupby("Description")['Revenue']
    .sum()
    .sort_values(ascending=False)
    .head(10)
)

plt.figure(figsize=(10,5))
sns.barplot(y=top_products.index, x=top_products.values)
plt.title("Top 10 Products by Revenue")
plt.xlabel("Revenue")
plt.ylabel("Product")
plt.show()

"""## 9Ô∏è‚É£ Top Customers by Revenue

We examine the top-spending customers and their contribution to total income.

"""

top_customers = (
    df.groupby("CustomerID")['Revenue']
    .sum()
    .sort_values(ascending=False)
    .head(10)
)

plt.figure(figsize=(10,5))
sns.barplot(x=top_customers.values, y=top_customers.index)
plt.title("Top 10 Customers by Revenue")
plt.xlabel("Revenue")
plt.ylabel("Customer ID")
plt.show()

"""## üîü Distribution Analysis

We visualize the distribution of:
- Purchased quantities  
- Unit prices  
to detect skewness and unusual patterns.

"""

plt.figure(figsize=(8,5))
sns.histplot(df['Quantity'], bins=50, kde=True)
plt.xlim(0, df['Quantity'].quantile(0.99))
plt.title("Quantity Distribution")
plt.show()

plt.figure(figsize=(8,5))
sns.histplot(df['UnitPrice'], bins=50, kde=True)
plt.xlim(0, df['UnitPrice'].quantile(0.99))
plt.title("Unit Price Distribution")
plt.show()

"""## 1Ô∏è‚É£1Ô∏è‚É£ RFM Analysis (Recency ‚Äì Frequency ‚Äì Monetary)

RFM is a powerful technique used in marketing and CRM.

- **Recency:** Days since the last purchase  
- **Frequency:** Number of unique transactions  
- **Monetary:** Total spending  

We compute RFM metrics for each customer.

"""

# We define a reference date = last date in dataset
reference_date = df['InvoiceDate'].max()

rfm = df.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (reference_date - x.max()).days
}).rename(columns={'InvoiceDate': 'Recency'})

frequency = df.groupby('CustomerID')['InvoiceNo'].nunique()
rfm['Frequency'] = frequency

monetary = df.groupby('CustomerID')['Revenue'].sum()
rfm['Monetary'] = monetary

rfm.head()
rfm.describe()

rfm['R_score'] = pd.qcut(rfm['Recency'], 4, labels=[4,3,2,1])

f_bins = pd.qcut(rfm['Frequency'], 4, duplicates='drop')
f_labels = range(1, len(f_bins.cat.categories) + 1)

rfm['F_score'] = pd.qcut(
    rfm['Frequency'],
    q=4,
    labels=f_labels,
    duplicates='drop'
)

m_bins = pd.qcut(rfm['Monetary'], 4, duplicates='drop')
m_labels = range(1, len(m_bins.cat.categories) + 1)

rfm['M_score'] = pd.qcut(
    rfm['Monetary'],
    q=4,
    labels=m_labels,
    duplicates='drop'
)

rfm['RFM_Score'] = (
    rfm['R_score'].astype(str) +
    rfm['F_score'].astype(str) +
    rfm['M_score'].astype(str)
)

rfm['RFM_Sum'] = (
    rfm['R_score'].astype(int) +
    rfm['F_score'].astype(int) +
    rfm['M_score'].astype(int)
)

"""## 1Ô∏è‚É£2Ô∏è‚É£ RFM Scoring

We transform Recency, Frequency, and Monetary values into 4-level scores using quantiles.

We generate:

- `R_score`
- `F_score`
- `M_score`
- `RFM_Score` (string form, e.g., "432")
- `RFM_Sum` (numeric score used for segmentation)

"""

def rfm_segment(score):
    if score >= 10:
        return 'Champions'
    elif score >= 8:
        return 'Loyal Customers'
    elif score >= 6:
        return 'Potential Loyalists'
    elif score >= 4:
        return 'At Risk'
    else:
        return 'Hibernating'

rfm['Segment'] = rfm['RFM_Sum'].apply(rfm_segment)

"""## 1Ô∏è‚É£3Ô∏è‚É£ RFM Customer Segments

We classify customers into meaningful business groups:

- **Champions**  
- **Loyal Customers**  
- **Potential Loyalists**  
- **At Risk**  
- **Hibernating**

These segments help with targeted marketing strategies.

"""

rfm['Segment'].value_counts()

rfm.groupby('Segment')[['Recency','Frequency','Monetary']].mean()

"""## 1Ô∏è‚É£4Ô∏è‚É£ RFM Visualizations

We visualize:

- Distribution of customers across segments  
- Average Recency, Frequency, and Monetary scores per segment (heatmap)

"""

plt.figure(figsize=(10,5))
sns.countplot(data=rfm, x='Segment', order=rfm['Segment'].value_counts().index)
plt.title("Customer Segments Distribution")
plt.xticks(rotation=45)
plt.show()

segment_summary = rfm.groupby('Segment')[['Recency','Frequency','Monetary']].mean()

plt.figure(figsize=(8,6))
sns.heatmap(segment_summary, annot=True, fmt=".1f", cmap="Blues")
plt.title("RFM Averages per Segment")
plt.show()

rfm.to_excel("RFM_results.xlsx", index=True)

files.download("RFM_results.xlsx")

"""## 1Ô∏è‚É£5Ô∏è‚É£ K-Means Clustering on RFM Metrics

We apply K-Means to the scaled RFM variables:

- Standard scaling  
- Elbow method to determine best K  
- Fitting the K-Means model  
- 3D scatter plot of RFM clusters  

This adds a machine learning component to the analysis.

"""

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm[['Recency','Frequency','Monetary']])

from sklearn.cluster import KMeans

wcss = []
for k in range(1,11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(rfm_scaled)
    wcss.append(kmeans.inertia_)

plt.figure(figsize=(7,4))
plt.plot(range(1,11), wcss, marker='o')
plt.title("Elbow Method")
plt.xlabel("Number of Clusters")
plt.ylabel("WCSS")
plt.show()

kmeans = KMeans(n_clusters=5, random_state=42)
rfm['Cluster'] = kmeans.fit_predict(rfm_scaled)
rfm['Cluster'] = rfm['Cluster'].astype(str)

from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(10,7))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(
    rfm['Recency'], rfm['Frequency'], rfm['Monetary'],
    c=rfm['Cluster'].astype(int), cmap='tab10'
)

ax.set_xlabel('Recency')
ax.set_ylabel('Frequency')
ax.set_zlabel('Monetary')
ax.set_title('RFM Clusters (3D View)')
plt.show()

"""## ‚úÖ Final Conclusions & Business Recommendations

### üèÜ Champions
- Highly active and high-value customers  
‚úÖ Provide exclusive rewards and early access to new products

### ‚ù§Ô∏è Loyal Customers
- Stable purchasing behavior  
‚úÖ Promote loyalty program upgrades and personalized offers

### üå± Potential Loyalists
- Promising customers with recent activity  
‚úÖ Use personalized recommendations and targeted campaigns

### ‚ö†Ô∏è At Risk
- Previously active but declining  
‚úÖ Send win-back emails and limited-time discounts

### üí§ Hibernating
- No recent activity  
‚úÖ Reactivation campaigns and reminders

---

This analysis provides actionable insights for customer relationship management, revenue growth, and data-driven marketing strategies.

"""

